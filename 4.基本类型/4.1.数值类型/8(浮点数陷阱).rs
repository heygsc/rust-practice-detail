//题目
//使用两种方法来让下面代码工作
fn main() {
    assert!(0.1+0.2==0.3);
}

//方法1
//答案
fn main() {
    assert!(0.1_f32+0.2_f32==0.3_f32);
}
//讲解
// 题目中，不等于是因为，浮点数底层会转成二进制。
// 不同于整数，整数都可以转成普通的二进制。
// 而有限长度的十进制小数，转成二进制，可能小数点后会有无限循环的情况。这时候相加，只会取部分长度，取不到无限长度，所以最后算出的结果未必相等。
// 第一种方法，就是确定类型都为f32，让极限长度都相等。它们的最后一位加到一起，比较之后正好也相等。
// 注意，这里不可以类型为f64。
// 因为f64精度高些，算出的0.1+0.2和0.3，恰巧结尾有区别，不会判为相等。

//方法2
//答案
fn main() {
    assert!((0.1_f64+ 0.2 - 0.3).abs() < 0.001);
}
//讲解
// 第2种方法。
// 我们计算0.1+0.2是否为0.3，其实可以转化为0.1+0.2-0.3是否为0。
// abs()指绝对值。
// 如果0.1+0.2-0.3的绝对值特别小，比如这里小于0.001，接近0，就视为相等。
